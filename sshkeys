#!/usr/bin/env python3
import sys, getpass, subprocess, time, sqlite3, os, pwd
from pathlib import Path
import pyotp

DB_PATH = Path("/var/lib/risktotp/secure_totp.db")
MAX_FAILS = 3
BLOCK_SECONDS = 300

# common prefixes for sshkeys
ALLOWED_PREFIXES = (
    'ssh-ed25519',
    'ssh-rsa',
    'ecdsa-sha2-',
    'sk-ssh-ed25519@',
    'sk-ecdsa-sha2-'
)

def check_ssh_dir(user):
    #we only need pwd for the user
    pw = pwd.getpwnam(user)
    home = Path(pw.pw_dir)
    uid, gid = pw.pw_uid, pw.pw_gid

    ssh_dir = home / ".ssh"
    auth_keys = ssh_dir / "authorized_keys"

    # symlink check
    if ssh_dir.exists() and ssh_dir.is_symlink():
        print("~/.ssh является symlink — отказ.")
        sys.exit(1)
    if auth_keys.exists() and auth_keys.is_symlink():
        print("authorized_keys является symlink — отказ.")
        sys.exit(1)

    # create ~/.ssh
    if not ssh_dir.exists():
        ssh_dir.mkdir(mode=0o700, parents=True)
        os.chown(ssh_dir, uid, gid)
    else:
        os.chmod(ssh_dir, 0o700)
        os.chown(ssh_dir, uid, gid)

    # create auth_keys dir
    if not auth_keys.exists():
        auth_keys.touch(mode=0o600)
        os.chown(auth_keys, uid, gid)
    else:
        os.chmod(auth_keys, 0o600)
        os.chown(auth_keys, uid, gid)

    #pass uid and gid for file chown
    return ssh_dir, auth_keys, uid, gid

def add_pubkey(user, key_line):
    key_line = key_line.strip()

    # format check
    if not any(key_line.startswith(p) for p in ALLOWED_PREFIXES):
        print("Ключ не похож на SSH public key (неверный префикс).")
        sys.exit(1)
    if "\n" in key_line or "\r" in key_line:
        print("Ключ должен быть одной строкой.")
        sys.exit(1)

    _, auth_keys, uid, gid = check_ssh_dir(user)

    # read keys and check for existing
    existing = auth_keys.read_text(errors="ignore").splitlines()
    if key_line in existing:
        return

    #append to the end
    with auth_keys.open("a", encoding="utf-8") as f:
        f.write(key_line + "\n")

    #set rights
    os.chmod(auth_keys, 0o600)
    os.chown(auth_keys, uid, gid)

def init_db():
    DB_PATH.parent.mkdir(parents=True, exist_ok=True)
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("""
        CREATE TABLE IF NOT EXISTS attempts (
            user TEXT NOT NULL,
            action TEXT NOT NULL,
            fail_count INTEGER NOT NULL,
            last_fail_ts INTEGER NOT NULL,
            PRIMARY KEY(user, action)
        )
    """)
    conn.commit()
    return conn

def get_attempt(conn, user, action):
    c = conn.cursor()
    c.execute("SELECT fail_count, last_fail_ts FROM attempts WHERE user=? AND action=?",
              (user, action))
    row = c.fetchone()
    return (row[0], row[1]) if row else (0, 0)

def set_attempt(conn, user, action, fail, ts):
    c = conn.cursor()
    c.execute("""
      INSERT INTO attempts(user, action, fail_count, last_fail_ts)
      VALUES (?, ?, ?, ?)
      ON CONFLICT(user, action) DO UPDATE SET
        fail_count=excluded.fail_count,
        last_fail_ts=excluded.last_fail_ts
    """, (user, action, fail, ts))
    conn.commit()

def check_bruteforce(conn, user, action):
    fail, last = get_attempt(conn, user, action)
    now = int(time.time())
    if fail >= MAX_FAILS and now - last < BLOCK_SECONDS:
        wait = BLOCK_SECONDS - (now - last)
        print(f"Слишком много неверных кодов. Попробуйте через {wait} секунд.")
        sys.exit(1)

def verify_totp_for_operator(operator):
    ga_file = Path(f"/home/{operator}/.google_authenticator")
    if not ga_file.exists():
        print("Нет файла .google_authenticator у оператора.")
        sys.exit(1)
    secret = ga_file.read_text().splitlines()[0].strip()
    totp = pyotp.TOTP(secret)
    code = getpass.getpass("Введите TOTP-код оператора: ").strip()
    return totp.verify(code, valid_window=1)

def main():
    if len(sys.argv) != 4:
        print(f"Использование: {Path(sys.argv[0]).name} <user> add <public_key>")
        sys.exit(1)

    try:
        target = sys.argv[1]
        key = sys.argv[2]
        operator = os.environ.get("SUDO_USER")
        action = "secure-sshkeys"

        conn = init_db()
        check_bruteforce(conn, operator, action)

        if not verify_totp_for_operator(operator):
            print("Неверный TOTP-код.")
            fail, _ = get_attempt(conn, operator, action)
            set_attempt(conn, operator, action, fail + 1, int(time.time()))
            time.sleep(2)
            sys.exit(1)

        set_attempt(conn, operator, action, 0, int(time.time()))


        add_pubkey(target, key)
    except KeyboardInterrupt:
        print('\n')
        sys.exit(130)

if __name__ == "__main__":
    main()