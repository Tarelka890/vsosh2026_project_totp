#!/usr/bin/python3
import sys, getpass, subprocess, time, sqlite3, os
from pathlib import Path
import pyotp
import argparse, pwd, re

DB_PATH = Path("/var/lib/risktotp/secure_totp.db")
USER_RE = re.compile(r"^[a-z_][a-z0-9_-]{0,31}$")
ALLOWED_GROUPS = {"developers", "operators", "test_group"} #redact this for your use
DEFAULT_SHELL = "/bin/bash"
MAX_FAILS = 3
BLOCK_SECONDS = 300

def require_sudo_user():
    op = os.environ.get("SUDO_USER")
    if not op:
        print("Запускайте через sudo (нужна переменная SUDO_USER).")
        sys.exit(1)
    return op

def validate_user_exists(username):
    if not USER_RE.match(username):
        print("Некорректное имя пользователя.")
        sys.exit(2)
    try:
        pwd.getpwnam(username)
    except KeyError:
        print(f"Пользователь '{username}' не найден.")
        sys.exit(2)

def validate_new_username(username):
    if not USER_RE.match(username):
        print("Некорректное имя пользователя.")
        sys.exit(2)

def validate_groups(groups_csv):
    groups = [g.strip() for g in groups_csv.split(",") if g.strip()]
    if not groups:
        print("Группы не указаны.")
        sys.exit(2)
    bad = [g for g in groups if g not in ALLOWED_GROUPS]
    if bad:
        print("Запрещённые группы:", ", ".join(bad))
        sys.exit(2)
    return ",".join(groups)

def init_db():
    DB_PATH.parent.mkdir(parents=True, exist_ok=True)
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("""
        CREATE TABLE IF NOT EXISTS attempts (
            user TEXT NOT NULL,
            action TEXT NOT NULL,
            fail_count INTEGER NOT NULL,
            last_fail_ts INTEGER NOT NULL,
            PRIMARY KEY(user, action)
        )
    """)
    conn.commit()
    return conn

def get_attempt(conn, user, action):
    c = conn.cursor()
    c.execute("SELECT fail_count, last_fail_ts FROM attempts WHERE user=? AND action=?",
              (user, action))
    row = c.fetchone()
    return (row[0], row[1]) if row else (0, 0)

def set_attempt(conn, user, action, fail, ts):
    c = conn.cursor()
    c.execute("""
      INSERT INTO attempts(user, action, fail_count, last_fail_ts)
      VALUES (?, ?, ?, ?)
      ON CONFLICT(user, action) DO UPDATE SET
        fail_count=excluded.fail_count,
        last_fail_ts=excluded.last_fail_ts
    """, (user, action, fail, ts))
    conn.commit()

def check_bruteforce(conn, user, action):
    fail, last = get_attempt(conn, user, action)
    now = int(time.time())
    if fail >= MAX_FAILS and now - last < BLOCK_SECONDS:
        wait = BLOCK_SECONDS - (now - last)
        print(f"Слишком много неверных кодов. Попробуйте через {wait} секунд.")
        sys.exit(1)

def verify_totp_for_operator(operator):
    ga_file = Path(f"/home/{operator}/.google_authenticator")
    if not ga_file.exists():
        print("Нет файла .google_authenticator у оператора.")
        sys.exit(1)
    secret = ga_file.read_text().splitlines()[0].strip()
    totp = pyotp.TOTP(secret)
    code = getpass.getpass("Введите TOTP-код оператора: ").strip()
    return totp.verify(code, valid_window=1)

def build_parser():
    p = argparse.ArgumentParser(prog=Path(sys.argv[0]).name)

    sp = p.add_subparsers(dest="cmd", required=True)

    # ===== useradd =====
    pa = sp.add_parser("useradd", help="Создать пользователя (ограниченный набор опций)")
    pa.add_argument("user", help="новый пользователь")
    pa.add_argument("--shell", default=DEFAULT_SHELL, help="разрешённый shell (по умолчанию /bin/bash)")
    pa.add_argument("--create-home", action="store_true", default=True, help="создать home (по умолчанию да)")

    # ===== usermod =====
    pm = sp.add_parser("usermod", help="Изменить пользователя (allow-list)")
    sm = pm.add_subparsers(dest="op", required=True)

    pl = sm.add_parser("lock", help="Заблокировать пользователя")
    pl.add_argument("user")

    pu = sm.add_parser("unlock", help="Разблокировать пользователя")
    pu.add_argument("user")

    pg = sm.add_parser("add-groups", help="Добавить в разрешённые группы (только -aG)")
    pg.add_argument("user")
    pg.add_argument("groups", help="через запятую, напр. developers,operators")

    return p

def main():
    operator = require_sudo_user()
    conn = init_db()

    parser = build_parser()
    ns = parser.parse_args()

    # action для БД попыток — разный для разных команд
    action = f"secure-{ns.cmd}" if ns.cmd != "usermod" else f"secure-usermod:{ns.op}"


    try:
        check_bruteforce(conn, operator, action)

        if not verify_totp_for_operator(operator):
            print("Неверный TOTP-код.")
            fail, _ = get_attempt(conn, operator, action)
            set_attempt(conn, operator, action, fail + 1, int(time.time()))
            time.sleep(2)
            sys.exit(1)

        set_attempt(conn, operator, action, 0, int(time.time()))

        if ns.cmd == "useradd":
            validate_new_username(ns.user)
            if ns.shell != DEFAULT_SHELL:
                print("Запрещённый shell.")
                sys.exit(2)
            cmd = ["/usr/sbin/useradd"]
            if ns.create_home:
                cmd += ["-m"]
            cmd += ["-s", DEFAULT_SHELL, ns.user]
            subprocess.run(cmd)
            sys.exit(0)

        if ns.cmd == "usermod":
            validate_user_exists(ns.user)

            if ns.op == "lock":
                subprocess.run(["/usr/sbin/usermod", "-L", ns.user])
                sys.exit(0)

            if ns.op == "unlock":
                subprocess.run(["/usr/sbin/usermod", "-U", ns.user])
                sys.exit(0)

            if ns.op == "add-groups":
                groups = validate_groups(ns.groups)
                subprocess.run(["/usr/sbin/usermod", "-aG", groups, ns.user])
                sys.exit(0)

    except KeyboardInterrupt:
        print('\n')
        sys.exit(130)

if __name__ == "__main__":
    main()